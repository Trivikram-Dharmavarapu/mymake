'./mymake' is a simplified make program which will be performing operations based on dependencies specified in assignment. Its behavior closely resembles the UNIX make utility, supporting macros, target rules, and inference rules.

EXECUTION:

Prerequisites:
- Download .tar file.
- Make sure the remote servers must be accessible through SSH.
- Add MYPATH to environmental variables.
- Default mkaefile is mymake3.mk

Steps:
- Unzip .tar file.
    $ tar -xf <FileName>.tar
- Run 'make' to get executable files.
    $ make
- Execute ./mymake as explained below with necessary options and arguments.
- To clean the files use the command 'make clean' [removes all executable files (a.out), object files (*.o), backup files (*~), core dump files (core.*) ]
    $ make clean

USAGE:

- './mymake' in the following format:
    
    $ ./mymake [options] [target] [options]

FEATURES:

Options:

-f mf: Replace the default makefile with the specified file mf.
-p: Build the rules database from the makefile, output the rules, and exit.
-k: Continue execution even when some command fails.
-d: Print debugging information during execution, including applied rules and executed actions.
-i: Block the SIGINT signal to prevent interruption by Ctrl-C.
-t num: Run for up to approximately 'num' seconds, gracefully self-destructing if the program does not finish in time.

1. -f mf (Specify Makefile) Replace the default makefile with the specified file mf.

    - Sample Format:
        $ ./mymake -f <makefile>
    - Example:
        $ ./mymake -f makefile2

2. -p (Build Rules Database) - Build the rules database from the makefile, output the rules, and exit.

    - Sample Format:
        $ ./mymake -p
    - Example:
        $ ./mymake -f makefile2 -p

3. -k (Continue on Failure) - Continue execution even when some command fails.

    - Sample Format:
        $ ./mymake -k
    - Example:
        $ ./mymake -f makefile2 -k

4. -d (Debugging Information)-Print debugging information during execution, including applied rules and executed actions.

    - Sample Format:
        $ ./mymake -d
    - Example:
        $ ./mymake -f makefile2 -d

5. -i (Ignore Ctrl-C) - Block the SIGINT signal to prevent interruption by Ctrl-C.

    - Sample Format:
        $ ./mymake -i
    - Example:
        $ ./mymake -i -f makefile2

6. -t num (Timeout) - Run for up to roughly num seconds; gracefully self-destruct if the program does not finish in time.

    - Sample Format:
        $ ./mymake -t 20
    - Example:
        $ ./mymake -f makefile2 -t 30

7. Target - Specify a target to build; if not presented, the default target is the first target rule in the makefile.

    - Sample Format:
        $ ./mymake <target>
    - Example:
        $ ./mymake -f makefile2 clean

MORE EXAMPLES:
- Specify a custom makefile
    $ ./mymake -f makefile2

- Run a specific target rule
    $ ./mymake -f makefile2 clean

- Continue execution on command failure
    $ ./mymake -i clean -k

- Build rules database and output
    $ ./mymake -f makefile -p

ADDITIONAL FEATURES:

- Support for comments in the makefile using #.
- Special symbols $@ and $< in commands for inference rules.
- Use of macros in the form of $string or $(string) in commands.
- Handle circular dependencies in the makefile.
- Debugging information (-d) includes details about rules applied and actions executed.
- The > symbol is used to redirect the standard output of a command to a file.
- The < symbol is used to redirect the standard input of a command from a file.
- Multiple commands can be executed sequentially using the ; symbol.
- piped commands can be executed in sequence, passing the output of one command as input to the next.
- Cleaning process involves terminating all children and ensuring a complete cleanup.
- Exit messages indicate whether the program exited due to Ctrl-C or timeout.

Note:

- If there are any extra/unexpected options and arguments program will throw an invalid error.
- If the program encounters a loss of connection or failure to create a child process, errors are printed to the output.